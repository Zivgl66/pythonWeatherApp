#!groovy
pipeline {
environment {

REGISTRY_URL = "https://index.docker.io/v1/"
REGISTRY = "zivgl66/ziv-repo"
DOCKER_IMAGE = 'weatherapp'
VERSION = ''
IMG_TAG = ''
// MY_CREDENTIALS = credentials('gitlab_user_pass')

}
    agent any

    stages {
        stage('checkout') {
            steps {
               checkout scmGit(
                branches: [[name: "main"]],
                userRemoteConfigs: [[credentialsId: 'gitlab_api_token',
                url: 'http://172.31.29.37/root/weather-app.git']]
               )
            }
        }
         stage('Determine Version') {
            steps {
                script {
                    // Read the current version from version.txt
                    def versionFile = readFile 'version.txt'
                    echo "version in file is: ${versionFile}"
                    def (major, minor, patch) = versionFile.trim().tokenize('.').collect { it.toInteger() }

                    // Get the current branch name
                    def branch = sh(returnStdout: true, script: 'git rev-parse --abbrev-ref HEAD').trim()

                    // Determine the increment based on the branch type
                    def mergeCommitMessage = sh(returnStdout: true, script: 'git log -1 --pretty=%B').trim()
                    if (branch == 'master' && mergeCommitMessage.contains('Merge branch \'dev\'')) {
                        major += 1
                        minor = 0
                        patch = 0
                    } else if (branch == 'dev' && mergeCommitMessage.contains('Merge branch \'feature/')) {
                        minor += 1
                        patch = 0
                    } else if (branch == 'master' && mergeCommitMessage.contains('Merge branch \'hotfix/')) {
                        patch += 1
                    }

                    def newVersion = "${major}.${minor}.${patch}"
                    VERSION = newVersion
                    echo "Determined version: ${VERSION}"

                    // Write the new version back to version.txt
                    writeFile file: 'version.txt', text: newVersion
                }
            }  

        }
        // stage('Setup') {
        //     steps {
        //         echo 'cleaning...'
        //         sh 'yes | sudo docker system prune -a'
        //     }
        // }
        stage('Build') {
            steps {
                echo 'building...'
                sh "sudo docker build . -t ${DOCKER_IMAGE}"
            }
        }
        stage('Test') {
            steps {
                echo 'testing...'
                sh "sudo docker-compose down &&  sudo docker-compose up -d"
                sh 'weather_app/tests/test_conn.sh'
                echo 'test success'
                sh 'sudo docker stop $(sudo docker ps -a -q)'
                sh 'sudo docker rm $(sudo docker ps -a -q)'
            }
        }
        stage('Publish') {
            steps {
                script {
                    IMG_TAG = "${REGISTRY}:${DOCKER_IMAGE}-${VERSION}"
                }   
                sh "sudo docker tag weatherapp ${IMG_TAG}"
                script {
                sh "echo publishing..."
                docker.withRegistry("${REGISTRY_URL}", 'dockerhub_id') {
                    docker.image("${IMG_TAG}").push()
                    }
                }
            }
        }
        // stage('Push Version Update') {
        //     steps {
        //         withCredentials([usernamePassword(credentialsId: '1813952e-3498-4046-ba5d-54b0d4fd535b', usernameVariable: MY_CREDENTIALS_USR, passwordVariable: MY_CREDENTIALS_PSW)]) {
        //             script {
        //                 // Configure Git to use the credentials
        //                     // git config user.email "jenkins@example.com"
        //                 sh '''
        //                     git config user.name "root"
        //                     git config credential.helper store
        //                     echo "https://${MY_CREDENTIALS_USR}:${MY_CREDENTIALS_PSW}@gitlab.com" > ~/.git-credentials
        //                     git add version.txt
        //                     git commit -m "Update version to ${VERSION}"
        //                     git push origin HEAD
        //                     rm ~/.git-credentials
        //                 '''
        //             }
        //         }
        //     }
        // }
        // stage('EKS') {
        //     steps{
        //         script {
        //             sh "export IMAGE_TAG='${IMG_TAG}'"
        //             sh "aws eks update-kubeconfig --name pc-eks --region us-east-1"
        //             sh "cd /home/ubuntu/workspace/weather_app/EKS && envsubst < eks-manifest.yml | kubectl apply -f -"
        //             sh "cd /home/ubuntu/workspace/weather_app/EKS && kubectl apply -f elb-svc.yml"
        //         }
        //     }
        // }
        stage('EKS') {
            steps {
                script {
                    sh "export IMAGE_TAG='${IMG_TAG}'"
                    sh "aws eks update-kubeconfig --name pc-eks --region us-east-1"
                    sh "kubectl apply -f /home/ubuntu/workspace/weather_app/EKS/eks-manifest.yml --validate=false"
                    sh "kubectl apply -f /home/ubuntu/workspace/weather_app/EKS/alb-svc.yml --validate=false"
                }
            }
        }
        stage('Cleanup') {
            steps{
                sh "sudo docker rmi ${DOCKER_IMAGE}"
        }   
    }
    //     stage('Deploy') {
    //         steps{

    //             sshagent(credentials : ['ubuntu']) {
    //                 sh "sudo scp -i ~/weather_app_key.pem -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/nul -r ./prod/* ubuntu@54.91.89.34:~"
    //                 sh "ssh -o StrictHostKeyChecking=no ubuntu@54.91.89.34 sudo TAG=${VERSION} docker-compose down"
    //                 sh "ssh -o StrictHostKeyChecking=no ubuntu@54.91.89.34 sudo TAG=${VERSION} docker-compose up -d"
    //     }
    //     }
    // }
}
    // post {
    //     success {
    //         slackSend(channel: "succeeded-build", color: 'good', message: "successful build for: ${VERSION}")
    //     }
    //     failure {
    //         slackSend(channel: "devops-alerts", color: 'bad', message: "build failed for: ${VERSION}")
    //     }
    //     // always{
    //     //     // sh 'yes | sudo docker system prune -a'
    //     //     // cleanWs()
    //     // }
    // }
}
