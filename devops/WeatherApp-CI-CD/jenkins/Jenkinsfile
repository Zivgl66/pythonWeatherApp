#!groovy
pipeline {
environment {

REGISTRY_URL = "https://index.docker.io/v1/"
REGISTRY = "zivgl66/ziv-repo"
DOCKER_IMAGE = 'weatherapp'
VERSION = ''
IMG_TAG = ''
GITHUB_CREDENTIALS_ID = 'github_cred'
GITHUB_REPO_URL = "https://github.com/Zivgl66/version-control.git"

}
    agent any

    stages {
        stage('checkout') {
            steps {
                checkout scmGit(
                branches: [[name: "main"]],
                userRemoteConfigs: [[credentialsId: 'gitlab_api_token',
                url: 'http://172.31.29.37/root/weather-app.git']]
               )
            }
        }

         stage('Versioning') {
            steps {
                script {
                    sh 'rm -rf version-control'
                    sh "git clone https://github.com/Zivgl66/version-control.git"
                    sh "git checkout main"
                    def versionFile = readFile 'version-control/version.txt'

                    echo "version in file is: ${versionFile}"
                    def (major, minor, patch) = versionFile.trim().tokenize('.').collect { it.toInteger() }
                    def branch = env.gitlabBranch
                    echo "branch is: ${branch}"
                    def targetBranch = env.gitlabTargetBranch
                    echo "Target branch is: ${targetBranch}"
                    def mergeBranch = env.gitlabSourceBranch
                    echo "merge branch is: ${mergeBranch}"
                    if (targetBranch == 'main' && mergeBranch.contains('dev')) {
                        major += 1
                        minor = 0
                        patch = 0
                    } else if (targetBranch == 'dev' && mergeBranch.contains('feature')) {
                        minor += 1
                        patch = 0
                    } else if (targetBranch == 'main' && mergeBranch.contains('hotfix')) {
                        patch += 1
                    }

                    def newVersion = "${major}.${minor}.${patch}"
                    VERSION = newVersion
                    echo "Determined version: ${VERSION}"

                  
                    echo "Current Version: ${VERSION}"
                    echo "Version in File: ${versionFile}"
                    if (VERSION.trim() != versionFile.trim()) {
                        writeFile file: 'version-control/version.txt', text: VERSION
                        echo "Updated version in file: ${VERSION}"
                        sh 'git status'
                        withCredentials([usernamePassword(credentialsId: 'github_cred', passwordVariable: 'GIT_PASSWORD', usernameVariable: 'GIT_USERNAME')]) {
                            dir('version-control') {
                                sh 'git config user.email "admin@example.com"'
                                sh 'git config user.name "Administrator"'
                                sh 'git add version.txt'
                                sh "git commit -m 'increment version to ${VERSION}'"
                                sh "git push https://${GIT_USERNAME}:${GIT_PASSWORD}@github.com/Zivgl66/version-control.git HEAD:main --follow-tags -o integrations.skip_ci"
                            }
                        }
                    }
                    else {
                        echo 'nothing changed'
                    }
                }
            }  
        }
        stage('Build') {
            steps {
                echo 'building...'
                sh "sudo docker build . -t ${DOCKER_IMAGE}"
            }
        }
        stage('Test') {
            steps {
                echo 'testing...'
                sh "sudo docker-compose down &&  sudo docker-compose up -d"
                sh 'weather_app/tests/test_conn.sh'
                echo 'test success'
                sh 'sudo docker stop $(sudo docker ps -a -q)'
                sh 'sudo docker rm $(sudo docker ps -a -q)'
            }
        }
        stage('Publish') {
            steps {
                script {
                    IMG_TAG = "${REGISTRY}:${DOCKER_IMAGE}-${VERSION}"
                }   
                sh "sudo docker tag weatherapp ${IMG_TAG}"
                script {
                sh "echo publishing..."
                docker.withRegistry("${REGISTRY_URL}", 'dockerhub_id') {
                    docker.image("${IMG_TAG}").push()
                    }
                }
            }
        }
    
        stage('Deploy to EKS') {
            steps {
                script {
                    sh "export IMAGE_TAG='${IMG_TAG}'"
                    sh "aws eks update-kubeconfig --name pc-eks --region us-east-1"
                    sh "sed -e 's|VERSION|${VERSION}|g' /home/ubuntu/workspace/weather_app/EKS/eks-manifest.yml | kubectl apply -f /home/ubuntu/workspace/weather_app/EKS/eks-manifest.yml --validate=false"
                    // sh "kubectl apply -f /home/ubuntu/workspace/weather_app/EKS/eks-manifest.yml --validate=false"
                    sh "kubectl apply -f /home/ubuntu/workspace/weather_app/EKS/alb-svc.yml --validate=false"
                }
            }
        }
        stage('Cleanup') {
            steps{
                sh "sudo docker rmi ${DOCKER_IMAGE}"
        }   
    }
}
    post {
        success {
            slackSend(channel: "succeeded-build", color: 'good', message: "successful build for: ${VERSION}")
        }
        failure {
            slackSend(channel: "devops-alerts", color: 'bad', message: "build failed for: ${VERSION}")
        }
        // always{
        //     // sh 'yes | sudo docker system prune -a'
        //     // cleanWs()
        // }
    }
}